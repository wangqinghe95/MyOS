# 从零开始制作 MyOS（七）

## 引言

今天的目标是完善中断系统的其他功能

1. 通用保护故障
2. 页故障
3. 双重故障

## 什么是通用保护故障

通用保护故障，英文名：General Protection Fault。当CPU在执行指令过程中检测到违反了保护性规则，但又无法归入到其他更具体的异常（如页故障，堆栈故障等），就会触发此故障。

注意用于捕捉所有未定义的，或一般性的保护性错误。

## GPF 常见原因：

1. 内存访问越界
2. 向代码段写入数据
3. 从不可执行的段中读取指令
4. 使用空选择子访问内容
    + 如果一个段寄存器（如DS、ES、FS、GS）被加载了一个“空选择子”（通常指索引为0，指向GDT中第一个无效条目），然后又用这个段寄存器去访问内存，就会触发GPF。
5. 特权级违规
    + x86有4个特权级（Ring 0~3）。低特权级（如用户态的Ring 3）代码不能访问高特权级（如内核态的Ring 0）的数据段或调用高特权级的代码段，除非通过特定的门描述符。违反此规则会触发GPF。
6. 描述符表界限超出
    + 当使用超出全局描述符表或局部描述符表界限的选择子来加载段寄存器时，会触发GPF。

## GPF 错误代码

GPF是一个带错误码的异常。这个错误码提供了关于故障原因的关键信息，你的异常处理程序必须从栈中弹出这个错误码，否则会导致栈不平衡和后续问题。

错误码的结构如下：
Bit:    | 31---16 | 15 | 14 | 13 | 12 | 11---1 | 0 |
Content:|  保留   | TI | IDT|   索引               | EXT |

+ EXT (Bit 0)： 外部事件。如果置1，表示异常由外部事件（如硬件中断）在交付过程中触发。
+ IDT (Bit 1)： 如果置1，表示错误码索引引用的是IDT（中断描述符表）中的一个门描述符；如果为0，则引用GDT或LDT。
+ TI (Bit 2)： 表指示器。只有当IDT=0时有效。如果为0，表示选择子引用GDT；如果为1，引用LDT。
+ 索引 (Bit 3~15)： 在指定表（GDT, LDT或IDT）中的索引。

总结来说：
+ 如果错误码是一个选择子（比如0x08, 0x10），那么通常是段相关的问题（原因1, 2, 3, 4）。
+ 如果错误码是0，则可能是特权级问题（原因5）或其他内部问题。

## 代码

### interrupt.h

```interrupt.h
#ifndef INTERRUPT_H
#define INTERRUPT_H

#include "types.h"

/* 中断栈帧结构体 - 必须与汇编代码栈布局匹配 */
struct interrupt_frame {
    uint32_t gs, fs, es, ds;    // 保存发生中断前数据段寄存器状态
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;     // 通用寄存器 
    uint32_t int_no, err_code;  // 中断信息——中断号和错误码

    /* CPU 保存
    *   eip: 发生中断时正在执行的指令地址
    *   cs: 代码段选择子，包含特权级信息
    *   eflags: 标志寄存器状态
    *   user_esp: 用户态栈指针
    *   ss: 用户态栈段选择子
    */
    uint32_t eip, cs, eflags, user_esp, ss;  
};

/* 函数声明 */
void idt_init(void);
void idt_load(uint32_t idt_ptr);

/* 汇编函数声明 */
extern void isr0(void);
extern void isr13(void);

/* 异常处理函数 */
void divide_by_zero_handler(struct interrupt_frame* frame);
void general_protection_fault_handler(struct interrupt_frame* frame);
void default_exception_handler(struct interrupt_frame* frame);

#endif
```

新增通用保护中断处理函数；
新增通用中断isr13标签声明；
新增中断保存结构体

### interrupt.asm

```interrupt.asm
section .text

; 外部C函数
extern divide_by_zero_handler
extern general_protection_fault_handler
extern default_exception_handler

; 全局符号
global idt_load
global isr0, isr13

; 加载IDT
idt_load:
    mov eax, [esp + 4]  ; 获取IDT指针
    lidt [eax]          ; 加载IDT
    ret

%macro ISR_NOERRCODE 1
global isr%1
isr%1:
    cli
    push byte 0         ; 压入伪错误码
    push byte %1        ; 压入中断号
    jmp isr_common
%endmacro

%macro ISR_ERRCODE 1
global isr%1
isr%1:
    cli
    push byte %1        ; 压入中断号 (CPU已压入错误码)
    jmp isr_common
%endmacro

; 定义具体的中断处理程序
ISR_NOERRCODE 0    ; 除零异常
ISR_ERRCODE 13     ; 通用保护故障

; 通用中断处理程序
isr_common:
    ; 保存所有寄存器 - 顺序必须与C结构体匹配
    pusha               ; edi, esi, ebp, esp, ebx, edx, ecx, eax
    push ds
    push es
    push fs
    push gs

    ; 设置内核数据段
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; 根据新的栈布局获取中断号
    ; 栈布局: gs(4)+fs(4)+es(4)+ds(4)+pusha(32)=48字节
    mov eax, [esp+48]   ; 获取中断号

    ; 根据中断号调用对应的C处理函数
    cmp eax, 0
    je .call_divide_zero
    cmp eax, 13
    je .call_general_protection
    jmp .call_default

.call_divide_zero:
    push esp            ; 传递栈帧指针给C函数
    call divide_by_zero_handler
    add esp, 4
    jmp .done

.call_general_protection:
    push esp            ; 传递栈帧指针给C函数
    call general_protection_fault_handler
    add esp, 4
    jmp .done

.call_default:
    push esp
    call default_exception_handler
    add esp, 4

.done:
    ; 恢复寄存器
    pop gs
    pop fs
    pop es
    pop ds
    popa

    add esp, 8          ; 跳过int_no和err_code

    sti
    iret
```

上面的汇编代码中有两处需要说明一下：

#### 第一处
```
%macro ISR_NOERRCODE 1
global isr%1
isr%1:
    cli
    push byte 0         ; 压入伪错误码
    push byte %1        ; 压入中断号
    jmp isr_common
%endmacro

%macro ISR_ERRCODE 1
global isr%1
isr%1:
    cli
    push byte %1        ; 压入中断号 (CPU已压入错误码)
    jmp isr_common
%endmacro
```

这段代码是区分带错误码的中断和不带错误码的中断而定义的两个汇编函数，%1 的取第一个参数，在代码指令执行的过程中实际上指代的是 isr0, isr13 这种函数名

#### 第二处

```
isr_common:
    ; 保存所有寄存器 - 顺序必须与C结构体匹配
    pusha               ; edi, esi, ebp, esp, ebx, edx, ecx, eax
    push ds
    push es
    push fs
    push gs

    ; 设置内核数据段
    mov ax, 0x10
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax

    ; 根据新的栈布局获取中断号
    ; 栈布局: gs(4)+fs(4)+es(4)+ds(4)+pusha(32)=48字节
    mov eax, [esp+48]   ; 获取中断号

```

这段代码完成的任务是压栈：在中断的过程中，将各个寄存器的值保存下来，各个寄存器指的是 `interrupt.h:interrupt_frame` 结构体中定义好的寄存器，特别值得说明的是，结构体中的各寄存器的声明顺序要和上面汇编中栈布局得完全匹配。

完整的栈布局结构如下：

高地址
[ss]        ← 用户栈段 (CPU自动压入)
[user_esp]  ← 用户栈指针 (CPU自动压入)  
[eflags]    ← 标志寄存器 (CPU自动压入)
[cs]        ← 代码段 (CPU自动压入)
[eip]       ← 返回地址 (CPU自动压入)
[err_code]  ← 错误码 (CPU或软件压入)
[int_no]    ← 中断号 (软件压入)
[eax]       ← 通用寄存器 (pusha)
[ecx]       ← 通用寄存器 (pusha)  
[edx]       ← 通用寄存器 (pusha)
[ebx]       ← 通用寄存器 (pusha)
[esp]       ← 通用寄存器 (pusha - 注意这是中断前的ESP)
[ebp]       ← 通用寄存器 (pusha)
[esi]       ← 通用寄存器 (pusha)
[edi]       ← 通用寄存器 (pusha)
[ds]        ← 数据段 (软件压入)
[es]        ← 附加段 (软件压入)
[fs]        ← 附加段 (软件压入)
[gs]        ← 附加段 (软件压入)
低地址

偏移量的计算如下：

栈布局（从低到高）：
esp+00: gs
esp+04: fs  
esp+08: es
esp+12: ds
esp+16: edi (pusha第1个)
esp+20: esi (pusha第2个) 
esp+24: ebp (pusha第3个)
esp+28: esp (pusha第4个) ← 注意这是中断前的ESP值
esp+32: ebx (pusha第5个)
esp+36: edx (pusha第6个)
esp+40: ecx (pusha第7个)
esp+44: eax (pusha第8个)
esp+48: int_no
esp+52: err_code
esp+56: eip
esp+60: cs
esp+64: eflags
esp+68: user_esp
esp+72: ss

### interrupt.c

```
#include "interrupt.h"
#include "screen.h"

#define IDT_ENTRIES 256

/* IDT条目 */
struct idt_entry {
    uint16_t base_low;
    uint16_t selector;
    uint8_t zero;
    uint8_t flags;
    uint16_t base_high;
} __attribute__((packed));

struct idt_entry idt[IDT_ENTRIES];

/* IDT指针 */
struct idt_ptr {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));

static const char* exception_messages[] = {
    "Division By Zero",
    "Debug",
    "Non Maskable Interrupt", 
    "Breakpoint",
    "Into Detected Overflow",
    "Out of Bounds",
    "Invalid Opcode",
    "No Coprocessor",
    "Double Fault",
    "Coprocessor Segment Overrun",
    "Bad TSS",
    "Segment Not Present",
    "Stack Fault",
    "General Protection Fault",  // 索引13
    "Page Fault",
    "Unknown Exception",
    "x87 Floating-Point Exception",
    "Alignment Check",
    "Machine Check",
    "SIMD Floating-Point Exception"
};

/* 设置IDT门 */
static void idt_set_gate(uint8_t num, uint32_t base, uint16_t sel, uint8_t flags) {
    idt[num].base_low = base & 0xFFFF;
    idt[num].base_high = (base >> 16) & 0xFFFF;
    idt[num].selector = sel;
    idt[num].zero = 0;
    idt[num].flags = flags;
}

/* 初始化IDT */
void idt_init(void) {
    struct idt_ptr idtp;
    idtp.limit = (sizeof(struct idt_entry) * IDT_ENTRIES) - 1;
    idtp.base = (uint32_t)&idt;
    
    // 初始化所有IDT条目为0
    for(int i = 0; i < IDT_ENTRIES; i++) {
        idt_set_gate(i, 0, 0, 0);
    }

    /* 设置中断处理程序 */
    idt_set_gate(0, (uint32_t)isr0, 0x08, 0x8E);   // 除零异常
    idt_set_gate(13, (uint32_t)isr13, 0x08, 0x8E); // 通用保护故障
    
    /* 加载IDT */
    idt_load((uint32_t)&idtp); 
    
    printf("IDT initialized with exception handlers\n");
    printf("  - ISR0 (Divide Error) at: 0x%x\n", (uint32_t)isr0);
    printf("  - ISR13 (GPF) at: 0x%x\n", (uint32_t)isr13);
}

/* 默认异常处理 */
void default_exception_handler(struct interrupt_frame* frame) {
    const char* message = "Unknown Exception";
    if(frame->int_no < 20) {
        message = exception_messages[frame->int_no];
    }
    
    printf("\n=== UNHANDLED EXCEPTION %d (%s) ===\n", frame->int_no, message);
    printf("EIP: 0x%x, Error Code: 0x%x\n", frame->eip, frame->err_code);
    printf("CS: 0x%x, EFLAGS: 0x%x\n", frame->cs, frame->eflags);
    printf("System Halted\n");

    // 调试信息：显示一些寄存器值
    printf("Registers - EAX: 0x%x, EBX: 0x%x, ECX: 0x%x\n", 
           frame->eax, frame->ebx, frame->ecx);

    asm volatile("cli");
    while(1) asm volatile("hlt");    
}

/* 除零异常处理程序 */
void divide_by_zero_handler(struct interrupt_frame* frame) {
    printf("\n=== DIVIDE BY ZERO EXCEPTION ===\n");
    printf("Faulting Instruction: 0x%x\n", frame->eip);
    printf("Registers at fault:\n");
    printf("  EAX: 0x%x, EBX: 0x%x, ECX: 0x%x, EDX: 0x%x\n",
           frame->eax, frame->ebx, frame->ecx, frame->edx);
    printf("System Halted\n");
    
    asm volatile("cli");
    while(1) asm volatile("hlt");
}

/* 通用保护故障处理程序 */
void general_protection_fault_handler(struct interrupt_frame* frame) {
    printf("\n=== GENERAL PROTECTION FAULT ===\n");
    printf("Faulting Instruction: 0x%x\n", frame->eip);
    printf("Error Code: 0x%x\n", frame->err_code);
    printf("CS: 0x%x, EFLAGS: 0x%x\n", frame->cs, frame->eflags);
    
    // 错误码详细分析
    printf("Error Code Analysis:\n");
    if(frame->err_code & 0x01) {
        printf("  - External event caused fault\n");
    }
    if(frame->err_code & 0x02) {
        printf("  - Table: %s\n", (frame->err_code & 0x04) ? "LDT" : "GDT");
    }
    printf("  - Segment Index: %d\n", (frame->err_code >> 3) & 0x1FFF);
    
    // 显示更多上下文信息
    printf("Register State:\n");
    printf("  EAX: 0x%x, EBX: 0x%x\n", frame->eax, frame->ebx);
    printf("  ECX: 0x%x, EDX: 0x%x\n", frame->ecx, frame->edx);
    printf("  ESI: 0x%x, EDI: 0x%x\n", frame->esi, frame->edi);
    printf("  EBP: 0x%x, ESP: 0x%x\n", frame->ebp, frame->esp);
    
    printf("System Halted\n");
    
    asm volatile("cli");
    while(1) asm volatile("hlt");
}
```

### 运行结果：

如果 `interrupt.c::general_protection_fault_handler()` 中日志被打印出来，就说明通用保护故障中断正确被执行到了。

![General Protecion Fault](../resources/pic-1-7.png)

## 遇到的错误

Q. 中断的处理函数跳转不过去，只打印了前面的日志
A: 汇编代码中 `mov eax, [esp+48]   ; 获取中断号` 中断号计算获取有误
