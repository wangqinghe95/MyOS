# 从零开始制作 MyOS（六）—— 键盘输入中断

本节目标是：键盘中断开发

键盘中断开发没有背景知识，只需要按照以下步骤添加即可：

1. 添加键盘驱动代码
2. 在中断头文件中添加键盘中断启动程序
3. 添加键盘中断的汇编程序
4. 测试键盘驱动代码

## 1. 添加键盘驱动代码

### drivers/keyboard.h

```
#ifndef KEYBOARD_H
#define KEYBOARD_H

#include "types.h"

#define KEYBOARD_DATA_PORT 0x60
#define KEYBOARD_STATUS_PORT 0x64
#define KEYBOARD_COMMAND_PORT 0x64

void keyboard_init();
void keyboard_interrupt_handler();
char keyboard_read_scancode();
char keyboard_scancode_to_ascii(uint8_t scancode);
void keyboard_handle_input(char c);

#endif
```

1. 键盘数据端口和键盘状态端口


### drivers/keyboard.c

```
#include "keyboard.h"
#include "stdio.h"

#define INPUT_BUFFER_SIZE 256

static const char keyboard_map[128] = {
    0,  27, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', '\b',
    '\t', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', '\n',
    0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '`', 
    0, '\\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0,
    '*', 0, ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    '-', 0, 0, 0, '+', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    
};

static char input_buffer[INPUT_BUFFER_SIZE];
static uint32_t buffer_index = 0;

void keyboard_init()
{
    printf("Initializing keyboard...\n");

    uint8_t current_mask = inb(0x21);

    outb(0x21, current_mask & 0xFD);

    printf("Keyboard initialized (IRQ1 enabled)\n");
}

void keyboard_interrupt_handler()
{
    uint8_t scancode = keyboard_read_scancode();

    if(scancode < 128) {
        char c = keyboard_scancode_to_ascii(scancode);
        if(c != 0) {
            keyboard_handle_input(c);
        }
    }

    outb(0x20, 0x20);
}

char keyboard_read_scancode()
{
    return inb(KEYBOARD_DATA_PORT);
}

char keyboard_scancode_to_ascii(uint8_t scancode)
{
    if(scancode >= 128) return 0;
    return keyboard_map[scancode];
}

void keyboard_handle_input(char c)
{
    if(c == '\b') {
        if(buffer_index > 0) {
            buffer_index--;
            put_char('\b', make_color(WHITE, BLACK));
            put_char(' ', make_color(WHITE, BLACK));
            put_char('\b', make_color(WHITE, BLACK));
        }
    }
    else if(c == '\n') {
        put_char('\n', make_color(WHITE, BLACK));

        if(buffer_index > 0) {
            input_buffer[buffer_index] = '\0';
            printf("You typed: %s\n", input_buffer);
            buffer_index = 0;
        }

        printf("os > ");
    }
    else {
        if(buffer_index < INPUT_BUFFER_SIZE -1 ) {
            input_buffer[buffer_index++] = c;
            put_char(c, make_color(WHITE, BLACK));
        }
    }
}

```

1. keyboard_map
    + 扫描码
    + 按下事件：扫描码 = 1~127
    + 释放事件：扫描码 = 原值 + 128 
    + 示例：按下 'A' -> 扫描码 = 30；释放 'A' -> 扫描码 = （30+128）

2. keyboard_init()
    + 启动键盘中断（IRQ1）
    + inb(0x21): 读取当前 PIC 掩码
    + outb(0x21, current_mask & 0xFD);       // 0xFD = 11111101, 清除第1位

主PIC (0x21) 的8位掩码，每位对应一个IRQ：
位:   7     6       5       4       3       2       1       0
IRQ: IR7    IR6     IR5     IR4     IR3     IR2     IR1     IR0
设备: LPT2  FDC     COM2    COM1    LPT1    空      键盘    定时器

0xFD = 1111 1101 ← 第1位(IRQ1)为0，允许键盘中断


3. keyboard_interrupt_handler()
    + 检查状态：确保键盘真的有数据
    + 读取数据：从数据端口获取扫描码
    + 过滤处理：只处理按键按下，忽略释放
    + 通知PIC：中断处理完成，可以接收新中断

4. keyboard_handle_input()
    + 空格键处理
    + 回车键处理
    + 普通字符处理

## 2. 中断文件添加

### kernel/interrupt.h

```
void install_keyboard_interrupt(void);
extern void isr33(void);
```

### kernel/interrupt.c

```
void install_keyboard_interrupt(void)
{
    idt_set_gate(33, (uint32_t)isr33, 0x08, 0x8E);
    printf("Keyboard interrupt installed at vector 0x21 (IRQ1)\n");
}
```

## 3. 中断汇编代码添加

```

.call_keyboard:
    call keyboard_interrupt_handler
    jmp .done
```

## 键盘数据流总结

物理按键按下
    ↓
键盘控制器生成扫描码
    ↓
通过IRQ1向CPU发送中断
    ↓
CPU跳转到isr33 (中断向量0x21)
    ↓
keyboard_interrupt_handler() 执行
    ↓
读取扫描码 → 转换为ASCII
    ↓
keyboard_handle_input() 处理
    ↓
字符回显 + 缓冲区更新
    ↓
发送EOI，准备下一个中断


## 开发遭遇的问题

1. 系统未进入 kernel 
A: boot 中给的磁盘大小不够，新增到 32 个扇区

2. 测试时鼠标点到 Qemu 界面就蹦出通用保护错误
A: 系统启动后，没有执行 `install_keyboard_interrupt`，也就是说没有监听键盘中断

3. 测试键盘中断时，定时器中断的处理函数日志一直在打印，虽然字符串输入也能成功
A: 定时器中断设定的任务一直都会在执行，日志关闭即可。