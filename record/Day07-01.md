# 从零开始制作 MyOS（七）—— 物理内存分配

## 目标

1. 实现一个简单的物理内存分配方案

## 思路和步骤

1. 获取该系统当前拥有的物理内存大小
    + 采用硬编码+运行时参数方法

## 代码

### 1. 更新 Makefile

```
# 工具定义
CC = gcc
LD = ld
ASM = nasm
OBJCOPY = objcopy
QEMU = qemu-system-x86_64

# 目录结构
BOOT_DIR = boot
KERNEL_DIR = kernel
DRIVERS_DIR = drivers
SCRIPT_DIR = scripts

# 内存配置 - 可覆盖的默认值
QEMU_MEMORY ?= 64
KERNEL_MEMORY_MB ?= 64

# 编译和链接标志 - 传递内存大小给内核
CFLAGS = -m32 -nostdlib -ffreestanding -Wall -Wextra \
         -I$(KERNEL_DIR) -I$(DRIVERS_DIR) -I$(KERNEL_DIR)/memory \
         -DKERNEL_MEMORY_MB=$(KERNEL_MEMORY_MB)

LDFLAGS = -m elf_i386 -T $(SCRIPT_DIR)/linker.ld -nostdlib
ASFLAGS = -f elf32

# 自动查找源文件
KERNEL_C_SRCS = $(shell find $(KERNEL_DIR) -name "*.c" -not -name ".*")
DRIVER_C_SRCS = $(shell find $(DRIVERS_DIR) -name "*.c" -not -name ".*")
KERNEL_ASM_SRCS = $(shell find $(KERNEL_DIR) -name "*.asm" -not -name ".*")

# 推导目标文件
KERNEL_C_OBJS = $(KERNEL_C_SRCS:.c=.c.o)
DRIVER_C_OBJS = $(DRIVER_C_SRCS:.c=.c.o)
KERNEL_ASM_OBJS = $(KERNEL_ASM_SRCS:.asm=.asm.o)

# 正确的链接顺序
ALL_OBJS = $(KERNEL_ASM_OBJS) $(KERNEL_C_OBJS) $(DRIVER_C_OBJS)

# 最终目标
KERNEL_ELF = $(KERNEL_DIR)/kernel.elf
KERNEL_BIN = $(KERNEL_DIR)/kernel.bin
OS_IMAGE = myos.img

# 默认目标
all: $(OS_IMAGE)

# 生成操作系统镜像
$(OS_IMAGE): $(BOOT_DIR)/boot.bin $(KERNEL_BIN)
	@echo "Creating OS image..."
	dd if=/dev/zero of=$@ bs=512 count=2880
	dd if=$(BOOT_DIR)/boot.bin of=$@ conv=notrunc
	dd if=$(KERNEL_BIN) of=$@ bs=512 seek=1 conv=notrunc
	@echo "OS image created: $@"

# 编译引导程序
$(BOOT_DIR)/boot.bin: $(BOOT_DIR)/boot.asm
	@echo "Building bootloader..."
	$(ASM) -f bin $< -o $@

# 生成内核二进制文件
$(KERNEL_BIN): $(KERNEL_ELF)
	@echo "Creating kernel binary..."
	$(OBJCOPY) -O binary $< $@

# 链接内核
$(KERNEL_ELF): $(ALL_OBJS)
	@echo "Linking kernel..."
	@echo "Object files: $(words $(ALL_OBJS)) files"
	@echo "Configured memory: $(KERNEL_MEMORY_MB) MB"
	$(LD) $(LDFLAGS) -o $@ $(ALL_OBJS)
	@echo "Kernel linked: $@"

# 编译规则
%.c.o: %.c
	@echo "Compiling C: $< -> $@"
	$(CC) $(CFLAGS) -c $< -o $@

%.asm.o: %.asm
	@echo "Assembling: $< -> $@"
	$(ASM) $(ASFLAGS) $< -o $@

# 清理构建产物
clean:
	@echo "Cleaning build files..."
	rm -f $(OS_IMAGE) $(BOOT_DIR)/boot.bin $(KERNEL_BIN) $(KERNEL_ELF)
	find $(KERNEL_DIR) $(DRIVERS_DIR) -name "*.c.o" -delete
	find $(KERNEL_DIR) $(DRIVERS_DIR) -name "*.asm.o" -delete

# 显示详细的项目结构
debug:
	@echo "=== Build Configuration ==="
	@echo "Kernel memory: $(KERNEL_MEMORY_MB) MB"
	@echo "QEMU memory: $(QEMU_MEMORY) MB"
	@echo "Kernel ASM sources:"
	@for file in $(KERNEL_ASM_SRCS); do echo "  $$file"; done
	@echo "Kernel C sources:"
	@for file in $(KERNEL_C_SRCS); do echo "  $$file"; done
	@echo "Driver C sources:"
	@for file in $(DRIVER_C_SRCS); do echo "  $$file"; done
	@echo "All objects:"
	@for obj in $(ALL_OBJS); do echo "  $$obj"; done

# 运行目标 - 支持不同内存配置
run: $(OS_IMAGE)
	@echo "Starting QEMU with $(QEMU_MEMORY)MB RAM..."
	$(QEMU) -m $(QEMU_MEMORY) -drive format=raw,file=$(OS_IMAGE)

# 预定义的内存配置
run-16: $(OS_IMAGE)
	@echo "Starting QEMU with 16MB RAM..."
	$(QEMU) -m 16 -drive format=raw,file=$(OS_IMAGE)

run-32: $(OS_IMAGE)
	@echo "Starting QEMU with 32MB RAM..."
	$(QEMU) -m 32 -drive format=raw,file=$(OS_IMAGE)

run-64: $(OS_IMAGE)
	@echo "Starting QEMU with 64MB RAM..."
	$(QEMU) -m 64 -drive format=raw,file=$(OS_IMAGE)

run-128: $(OS_IMAGE)
	@echo "Starting QEMU with 128MB RAM..."
	$(QEMU) -m 128 -drive format=raw,file=$(OS_IMAGE)

# 构建时指定内存大小
build-16:
	@make clean
	@make KERNEL_MEMORY_MB=16

build-64:
	@make clean  
	@make KERNEL_MEMORY_MB=64

build-128:
	@make clean
	@make KERNEL_MEMORY_MB=128

.PHONY: all clean run run-16 run-32 run-64 run-128 build-16 build-64 build-128 debug
```

### 2. 新增内存管理头文件


```
// kernel/memory/memory.h

#ifndef MEMORY_H
#define MEMORY_H

#include "types.h"

/* 内存相关常量 */
#define PAGE_SIZE 4096
#define KERNEL_HEAP_START 0x100000  // 1MB以上作为内核堆

/* 如果没有在编译时定义，使用默认值 */
#ifndef KERNEL_MEMORY_MB
#define KERNEL_MEMORY_MB 64  // 默认64MB
#endif

#define TOTAL_MEMORY (KERNEL_MEMORY_MB * 1024 * 1024)
#define USABLE_MEMORY (TOTAL_MEMORY - 0x100000)  // 减去1MB以下区域

/* 内存区域描述符 */
struct memory_region {
    uint32_t base_addr;
    uint32_t length;
    uint32_t type;  // 1=可用, 其他=保留
};

/* 物理内存管理 */
void memory_init(void);
uint32_t get_total_memory(void);
uint32_t get_usable_memory(void);
uint32_t get_kernel_memory_mb(void);  // 新增：获取配置的MB数

/* 临时函数 - 后续实现 */
void init_bitmap_allocator(void);
void init_kernel_heap(void);
void* kmalloc(uint32_t size);
void kfree(void* ptr);

#endif
```

### 3. 新增内存管理实现 

// kernel/memory/memory.c

```
#include "memory.h"

#include "stdio.h"
#include "interrupt.h"

static uint32_t total_memory = 0;
static uint32_t usable_memory = 0;
static struct memory_region* memory_map = (struct memory_region*)(0x5000);
static uint32_t memory_map_entries = 0;

void detect_memory(void)
{
    printf("Memory Configuration:\n");
    printf("  Compiled for: %d MB\n", KERNEL_MEMORY_MB);
    printf("  Total memory: %d MB\n", TOTAL_MEMORY / (1024*1024));
    printf("  Usable memory: %d MB (above 1MB)\n", USABLE_MEMORY / (1024*1024));
    printf("  Page size: %d bytes\n", PAGE_SIZE);
    
    // 显示内存布局
    printf("Memory Layout:\n");
    printf("  0x00000000 - 0x000FFFFF: BIOS, VGA, Kernel (1MB)\n");
    printf("  0x00100000 - 0x%08X: Usable Memory (%d MB)\n", 
           TOTAL_MEMORY - 1, USABLE_MEMORY / (1024*1024));   
}

void memory_init(void)
{
    printf("Initializing memory management...\n");

    detect_memory();

    if (KERNEL_MEMORY_MB < 16) {
        printf("WARNING: Memory configuration < 16MB may be insufficient\n");
    }
    
    if (KERNEL_MEMORY_MB > 512) {
        printf("WARNING: Memory configuration > 512MB may be unrealistic\n");
    }

    // init_bitmap_allocator();
    // init_kernel_heap();

    printf("Memory magagement initialized\n");
}

uint32_t get_total_memory(void)
{
    return total_memory;
}

uint32_t get_usable_memory(void)
{
    return USABLE_MEMORY;
}

uint32_t get_kernel_memory_mb(void)
{
    return KERNEL_MEMORY_MB;
}

void* kmalloc(uint32_t size)
{

}

void kfree(void* ptr)
{

}


void set_bitmap(uint32_t bit)
{

}

void clear_bitmap(uint32_t bit)
{

}

uint32_t test_bitmap(uint32_t bit)
{

}

```

### 更新主内核文件

```
// kernel.c
#include "interrupt.h"
#include "stdio.h"
#include "memory.h"
#include "timer.h"
#include "keyboard.h"

void kernel_main(void) {
    clear_screen();
    printf("MyOS Boot - Memory: %d MB\n", get_kernel_memory_mb());
    printf("=========================================\n\n");
    
    // 1. 初始化中断系统
    idt_init();
    init_pic();
    install_timer_interrupt();
    install_keyboard_interrupt();
    
    // 2. 初始化内存管理系统
    memory_init();
    
    // 3. 初始化硬件驱动
    init_timer();
    keyboard_init();
    
    printf("\nKernel initialized successfully\n");
    printf("System ready with %d MB memory\n", get_kernel_memory_mb());
    
    // 启用中断
    asm volatile("sti");
    
    printf("Type 'help' for available commands\n");
    printf("os> ");
    
    while(1) {
        asm volatile("hlt");
    }
}
```

### 运行

1. 普通运行
```
# 默认64MB配置
make clean && make && make run

# 16MB小内存配置
make clean && make KERNEL_MEMORY_MB=16 && make run-16

# 128MB大内存配置  
make clean && make KERNEL_MEMORY_MB=128 && make run-128

# 或者使用快捷命令
make build-16 && make run-16
make build-64 && make run-64  
make build-128 && make run-128
```

2. 修改环境变量参数运行

```
# 临时修改默认内存大小
export KERNEL_MEMORY_MB=32
export QEMU_MEMORY=32
make clean && make && make run
```

## 问题

1. boot.asm 中分配的磁盘大小和 memory 中获取的内存分配代表什么
2. #define KERNEL_HEAP_START   (0x100000) 这个 0x100000 和内核地址 0x90000 有没有关联，后者的地址后续会需要做更改吗



